# Local Dev Instructions

## 1. Configure AWS CLI to Use Localstack

Update your AWS CLI configuration to point to Localstack instead of real AWS services.
Edit ~/.aws/config:

```
[profile localstack]
region = us-east-1
output = json
```

Edit ~/.aws/credentials:

```
[localstack]
aws_access_key_id = test
aws_secret_access_key = test
```

Set your shell environment variables to use the LocalStack profile:

```
export AWS_DEFAULT_PROFILE=localstack
export AWS_ENDPOINT_URL=http://localhost:4566
```

## 2. Install localstack and postgres via [docker](https://docs.docker.com/engine/install/) and docker-compose

```
docker-compose up -d
```

## 3. Deploy the lambda function

Create a Deployment Package and deploy the lambda to localstack:

```
npm run build:dev:init
```

This will generate an URL with a format similar to `http://someIDString.lambda-url.us-east-1.localhost.localstack.cloud:4566` which you can then use to make requests against using postgres/curl/etc.

## 4. Invoke the Lambda Function

If you want to manually invoke the function using the aws CLI you can use:

```
aws lambda invoke \
    --cli-binary-format raw-in-base64-out \
    --function-name apolis-api-dev \
    --payload fileb://dev-payload.json \
    --endpoint-url=http://localhost:4566 \
    output.json
```

Otherwise you should use the URL generated by the previous step.

## 5. Test and Debug

You can now test and debug your Node.js Lambda function locally.
You can view logs via: `docker logs -f localstack` and `docker logs -f postgres`
If you make changes to the js source, you can update the function via:

```
npm run build:dev
```

## 6. Clean Up

When you're done, stop the LocalStack and postgres containers:

```
sudo docker-compose down
```

If you also want to re-seed the database on the next run you can run:

```
sudo docker-compose down --volumes
```

This will clear out the docker volumes and force initialization the next time you bring the containers up.

# Seed Data
 The local development DB is created by the seed_dev.sql file. It mirrors the schema of the production DB and inserts a few records.
 If changes are made to the prod DB schema you can mirror this over to the dev environment via the following steps:
 1. Take a backup of the prod DB schema:
 ```
pg_dump --file "./seed_dev.sql" --host "get this value and the password for the apolis user from an admin" --port "5432" --username "apolis" --format=p --schema-only --no-owner --verbose "apolis"
```
2. Add back any seed rows you want at the end of the file
```
INSERT INTO public.users (email, role, sub) VALUES
 ('admin@apolis.dev', 'admin', 'somesub1'),
 ('manager@apolis.dev', 'manager', 'somesub2');

INSERT INTO public.services (name, quota) VALUES
 ('Service 1', 10),
 ('Service 2', 20),
 ('Service 3', 30);

INSERT INTO public.guests (first_name, last_name, dob, case_manager) VALUES
 ('John', 'Doe', '1990-01-01', 'Case Manager 1'),
 ('Jane', 'Doe', '1995-01-01', 'Case Manager 2');

INSERT INTO public.guest_services (guest_id, service_id, status) VALUES
 (1, 1, 'Queued'),
 (1, 2, 'Slotted'),
 (2, 3, 'Completed');
 ```
 3. Rebuild the DB
 ```
sudo docker-compose down --volumes
docker-compose up -d
```
